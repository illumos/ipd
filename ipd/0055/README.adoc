:showtitle:
:toc: left
:numbered:
:icons: font
:state: draft
:revremark: State: {state}
:authors: Kyle Simpson <kyle@oxide.computer>
:sponsor:
:source-highlighter: pygments
:stem: latexmath
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

= IPD 55 – Placing More Packet Info Into `dblk_t`
{authors}

[cols="3"]
|===
|Authors: {authors}
|Sponsor: {sponsor}
|State: {state}
|===

== Introduction

Network packets in illumos carry offload state in a packet chain's head `dblk_t`.
This allows MAC consumers to correctly instruct NIC drivers (and the MAC datapath itself) on how packets should be processed for delivery.
The mechanism today is that the `dblk_t` contains around 8 bytes of information in the `db_struioun` field – this comprises the current packet checksum (full/partial), the TCP _Maximum Segment Size_ (MSS), and flags denoting desired offloads.
Packet pullup/clone/modification operations are generally responsible for ensuring that this is kept up-to-date in any new/derived packets.

During transmission, the packet structure and its header lengths typically need to be known to execute the promises we have made on offloads.
NICs require each packet's layer types and offsets, which a driver reparses from first principles using `mac_ether_offload_info`.
For loopback delivery we rely on `mac_hw_emul` to perform checksum fixup and/or TCP packet segmentation, which again requires a reparse as above.
Yet in principle the kernel knows the packet structure (because it originated the packet!), and we should not need to waste cycles on re-establishing these facts.

The proposal here is that we move such information into the `dblk_t`: packets would be able to carry their header lengths and types from source to sink, which can be exported as a `mac_ether_offload_info_t`.
A call to `mac_ether_offload_info` would unpack this information if present, and parse the packet from first principles if it is not.
While this saves cycles in the transmit path, this change also has applicability to the MAC Rx datapath.
Some NICs report a packet's header types, lengths, and/or the RSS hash on receipt.
If a MAC provider were to set this information, this saves illumos from performing extra work during (sub-)flow classification, protocol fanout, etc.
https://code.illumos.org/c/illumos-gate/+/4176[Post-IPv6 fast path], `mac_ether_offload_info` is used today as the parsing implementation for these features.
This change also specifically benefits tunnel-aware offloads as part of link:../0056/README.adoc[IPD 56].
In this context storing a packet's tunnel type within the `dblk_t` to control offload behaviour is necessary at a bare minimum, but avoiding *two* header stack parses per packet is a significant win.

This work is currently implemented alongside link:../0056/README.adoc[IPD 56] in stlouis/Helios commit https://github.com/oxidecomputer/illumos-gate/commit/53ed1e30b6807e5e9d694326390914e7c53c0c94[53ed1e30b6807e5e9d694326390914e7c53c0c94].
The linked commit does not wire up upstream clients such as `ip` to fill out this information; we use this in the https://github.com/oxidecomputer/opte:[OPTE kernel module] after packet encapsulation and decapsulation, which benefits both viona and the downstream NICs used for packet transmit on the order of ~200Mbps.
As with IPD 56, this work has been in use in our development environments and customer releases for several months now.

== Proposal

Each `dblk_t` carries a _packed_ representation of the `mac_ether_offload_info_t`, taking advantage of known maximum sizes for each layer where possible.

.usr/src/uts/common/sys/stream.h
[code,c]
----
/* Ethernet Q-in-Q requires 22 Bytes. (5b -> max=31) */
#define	DBLK_L2HLEN_WIDTH	5
/* Max L4 is TCP -- 60 Bytes with options. (6b -> max=63) */
#define	DBLK_L4HLEN_WIDTH	6

#ifdef _KERNEL
CTASSERT((1 << DBLK_L2HLEN_WIDTH) - 1 >= 22);
CTASSERT((1 << DBLK_L4HLEN_WIDTH) - 1 >= 60);
#endif

typedef struct packed_meoi {
	/*
	 * The flags here contain values of type
	 * mac_ether_offload_flags.
	 */
	uint8_t flags;
	uint8_t l4proto;

	uint16_t l2hlen: DBLK_L2HLEN_WIDTH;
	uint16_t l4hlen: DBLK_L4HLEN_WIDTH;

	/* L3 len may be unbounded, thanks to IPv6EHs */
	uint16_t l3hlen;

	uint16_t l3proto;
} packed_meoi_t;

typedef struct datab {
	/* ... existing fields ... */

	/*
	 * This union is deliberately used for type punning, making it easier
	 * to check 'any valid info' and to unset all fields' validity on
	 * cleanup.
	 */
	union {
		uint8_t valid;
		packed_meoi_t pktinfo;
	} db_meoi;
} dblk_t;
----

This consumes an extra 8 bytes per `dblk_t` when accounting for a single layer of headers.
When accounting for an extra tunneled layer (link:../0056/README.adoc[IPD 56]), this would consume 16 bytes.

MAC providers and clients then query and set this information via the following `mac_provider.h` interface:

[code,c]
----
extern void mac_ether_offload_info(const mblk_t *, mac_ether_offload_info_t *);
extern void mac_ether_set_pktinfo(mblk_t *, const mac_ether_offload_info_t *);
extern void mac_ether_clear_pktinfo(mblk_t *);
extern boolean_t mac_ether_any_set_pktinfo(const mblk_t *mp);
----

The intent is that all consumers must strictly go through a function interface, to allow sufficient freedom to develop the underlying types as more capabilities are developed within MAC.
We do not want any proliferation of direct access to the `packed_meoi_t`, as has happened with macros like `DB_LSOMSS` vs. `mac_lso_get`.

Packet parse info is modified using `mac_ether_set_pktinfo` or `mac_ether_clear_pktinfo`.
These operations require a reference count of 1 on the `dblk_t`, which should be checked by the caller.
The call signature of `mac_ether_offload_info` is identical to that used today, serving as a drop-in replacement which _may_ rely on this information, if present.
Callers are allowed to provide partial information (e.g., L2 and L3, or L3 and L4), but it *must* be correct.
MAC or DLPI may choose to retrieve, modify, and then set this information as packets are modified or prepended to.

The disposition in our current implementation is to clear this information as it is delivered out of MAC (before handoff to DLPI or the fastpath to IP).
ICMP and ARP are paths known to reuse `mblk_t` s for the construction of replies, but doing so with incorrect offload flags could lead to the transmission of corrupted packets.
Clearing this state at the MAC boundary isolates us from this risk today, at the cost of preventing MAC clients from using packet parse data.
Another point is that the refcount behaviour of `ip` for TCP packets typically precludes us from having `mac_ether_offload_info` automatically set offload information on a packet after any successful parse.

== Impact

The `dblk_t` type is 8B larger (or 16B larger when tunnel-aware), relative to an initial 112B.
STREAMS-based interfaces are used more widely than just the netstack, thus costing more overhead per allocated STREAMS message.

The change in struct size also has an impact on how `dblk_t` caches are allocated.
`dblk_t` caches are constructed using cache line-aligned buffer sizes, with the buffer allocated adjacently for any size smaller than a page (4096B).
E.g., `common/io/stream.c` lists 16B and 80B as entries within `dblk_sizes[]`; these correspond to total `kmem_alloc` calls of 128B and 192B respectively.
An increase of 8B in `sizeof (dblk_t)` reduces the message buffers to 8B and 72B respectively.
An increase of 16B (link:../0056/README.adoc[IPD 56]) leads to the loss of the first such `kmem_cache`, leaving 64B as the smallest message buffer size.

== Prior Art

Linux handles network packets using the `struct skbuff` type.
Its documentation is <<skbuff, rendered here>> – the salient pieces are:

* `mac_header`, `network_header`, `transport_header` and their `inner_` variants store the byte offsets for the start of L2/L3/L4 headers using `uint16_t`.
The `mac_len` and `hdr_len` `uint16_t` fields serve a related purpose for the outer layers.
Validity of the inner fields here is gated on bitflags such as `encapsulation`.
* Outermost layers store their Ethertype in `protocol`, whereas some tunnel types may store either their Ethertype or IP Protocol.
* `struct sk_buff` stores a flow hash, along with indication as to whether it was software computed.
* Metadata is partially split into `struct skb_shared_info`, which includes `gso_size` and type.
* Checksum state and offsets are kept and signalled similarly to `dblk_t`.
* Other extension data (up to ~2KiB) can be allocated from a kmem cache and attached via a `struct skb_ext *` <<skb-ext>>.
Cases where these fields are set are treated as being quite out of the ordinary, if the `unlikely()` annotations are any indication.

Most importantly, the type is not really used for signalling between drivers in quite the way that STREAMS are, aside from where netlink sockets are used.
It's a fairly large type accounting for the 48B `cb` field used as scratch space when a packet is moving through a layer.
Otherwise the shape of things which live live in `struct sk_buff` are entirely geared towards the network datapath.
A useful takeaway is that most of the fields we care about here are crucial enough to make it into the main body of `struct skbuff`.

FreeBSD represents packets with the `struct mbuf` type.
This type holds a `struct pkthdr`, which accounts for around 64B of metadata, including packet lengths and LSO information.
Protocols don't appear to be directly included, but are rather indicated by the checksum flags.
The type contains two layers of packet headers, storing L2/3/4/5 lengths as `uint8_t`s.

== Future Developments

Once this capability is part of the kernel, we will want upstream MAC/DLPI clients who generate or modify network packets to emit this information where possible.
This includes:

* `ip`
  - `ip_xmit` can push L2 information when a fastpath NCE has been successfully negotiated.
  - `tcp_send` can set L3/L4 information, as it is aware of the placement/lengths of both header sets.
  - `udp_send` calls header prepend functions which can set L3/L4 information.
    - In both cases, there's some responsibility to ensure that L4 information is correctly stripped when needed with fragmentation in play.
  - `icmp_prepend_header_template` and related functions can set L3/L4 information.
  - `conn_ip_output` (or the downstream send methods) can set L3 information, using `ip_xmit_attr_t` (fields `ixa_protocol`, `ixa_ip_hdr_length`).
* `dls`/`mac` boundary
  - `mac_header` could set L2 info during slowpath processing.
* `overlay(7)`
  - `overlay` plugins could, at the very least, set outer header lengths for pushed encapsulation.
  - Particularly in light of IPD56, we could set both layers of packet info as OPTE does.
  E.g., extract the header info on a packet ready to be transmitted, and then set both the tunnel layer and inner.

SCTP has not really been discussed, since the `mac_ether_offload_info`/`mac_hw_emul` framework doesn't account for parsing the header class or emulating any offloads for the protocol.
In principle we should be able to use this framework here without issue once supported by emulation – SCTP CRC offloads are common enough, and we would most likely consider only the common header for `l4hlen`.
Linux also exposes a software-only kind of segmentation offloads here that we might want to plumb in future, where it segments the SCTP packet along chunk boundaries at the desired 'MSS' (chaining chunks via `struct sk_buff` to simplify iteration).

This pattern also allows a driver to aid the Rx pathway, since MAC will be able to quickly sort a packet into a fastpath without needing to perform a full parse.
There's value in including the RSS hash included with a packet on compatible NICs, but we will need to be able to signify that the hash has come from an unknown algorithm.
Fanout for TCP packets matches each flow-key to the TCP squeue that that flow is bound to – thus, we cannot use the output of an arbitrary hash algorithm for this purpose.
UDP/OTH fanout logic could benefit from having access to this, as could upstream devices like viona.

Explicitly tracking a packet's structure allows us, at some point, to reconsider the role of partial checksums in the network stack.
Given a fully parsed packet and today's checksum flags, we arguably have no need of `db_cksumstart`/`db_cksumend`/`db_cksumstuff`.
The offset of a packet checksum within its layer is, more often than not, fixed, and so easily derived from this context.
This would free up 24B within `dblk_t`, more than counteracting the cost of `packed_meoi_t` with or without link:../0056/README.adoc[IPD 56].

A more extreme proposal would use this as the basis for _removing_ partial checksums, and handling only the fully computed cases and offloaded cases.
This would free up flags in the provider interface (and generally simplify logic throughout the stack).
NICs which require a partial checksum would compute this themselves (using a `mac_provider` API) before transmission on the basis of the above parse data.

== Alternate directions

This proposal has packet info live unconditionally within `dblk_t`, and is similar in nature to FreeBSD and Linux's approaches of storing the state in the network packet type.
A possibility is that we could move all MAC-specific elements behind a pointer (as is done for extension data in Linux's `sk_buff`), and fill it from a separate `mblk_t` cache.
There are pros and cons to doing so.
This would greatly limit the impact on other STREAMS consumers, but would also allow for a packet to point at on-thread-stack data rather than *needing* an allocation or to access a kmem cache.
This does however greatly complicate the contracts of when packets should fill this information, how recipients should access it, and ensuring that any on-stack data is copied out if delivery becomes asynchronous (e.g., a packet is enqueued on a TX SRS or looped back into another squeue).
Principally, the extra layer of indirection makes the use of these fields (getting, setting) within the datapath more expensive, which is at odds with our goals around network performance.
Other Unices have decided that it's worth always paying the struct size cost here – but this is probably helped by the fact that their types are specialised for network packets first and foremost.
There may still be value in keeping this as an option for certain classes of auxiliary data.

Rather than forcing all information to be invalid on a boundary with MAC, an alternative approach would be to keep an additional `info_stale` flag within the packet data.
When crossing a boundary, MAC sets this flag, and a direct use of `mac_ether_offload_info` results in a full parse.
If a client wishes to make use of this info it can clear this flag, but in turn becomes responsible for either readding the flag, clearing the state, or ensuring the state is correct for the next recipient.
Readding the flag may be done at any time, allowing e.g. `ip` to be audited in a piecemeal way for any `mblk_t` reuse.

[bibliography]
== External References

- [[[skbuff]]] https://docs.kernel.org/networking/kapi.html#c.sk_buff
- [[[skb-ext]]] F. Westphal, 2019. SKB Metadata Extensions https://strlen.de/talks/skb_ext_slides.pdf
