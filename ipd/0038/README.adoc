:showtitle:
:toc: left
:numbered:
:icons: font
:state: draft
:revremark: State: {state}
:authors: Robert Mustacchi <rm@fingolfin.org>

= IPD 38 Signal Handling, Extended FPU State, ucontexts, x86, and You
{authors}

As of this writing, illumos does not properly preserve the extended x86
register state as part of signal handling. This issue is documented in
https://www.illumos.org/issues/15254[15254 %ymm registers not restored
after signal handler]. The main goals of this IPD are:

* To explain the challenges that we're facing and give appropriate
  context.
* To explain improvements to observability and the steps to fix this
  particular problem.
* Discuss forthcoming features on x86 that make this more challenging
  and how that changes are approach.
* Provide guidance for what should be done on future ports and other
  systems.

NOTE: Specifics of these proposals may change as we get into actual
implementation and we gain experience. This document will be updated to
reflect that.

== Summary of Proposed Changes

* Introduce a new `UC_XSAVE` to indicate that some portion of the
  extended state has been saved in signal handler context. This will be
  restored by `setcontext()`.
* Implement the `xregs` file and `PCSXREG` command in
  https://illumos.org/man/5/proc[proc(5)] using the proposed hybrid
  layout. This will also show up as an elfnote with support added to the
  appropriate tools.
* Change how the minimum and recommended signal and pthread stack sizes
  are implemented to be built on sysconf.
** Provide a way to dynamically query the kernel for this for a given
   process as it may change on a per-process basis in the future given
   other features like Intel AMX or a desire to support ARM SVE.
** Attempt to prevent newly compiled applications from using a signal
   stack that might cause then to be unable to receive a signal.
* Extend libproc, libc_db, mdb, and related to allow visibility and
  manipulation of the extended FPU state. Investigate variants that take
  care of the underlying structure information.

== Background

To fully understand what's going on, it's worth understanding several
different pieces and mechanisms that exist in the operating system and
CPUs that are all inter-related.

=== x86 FPU and its Endless Extensions

The x86 FPU and its state has a long and sordid history from its life as
a co-processor in the form of the Intel 80387 to its current state of
being a rather large vector processing unit. This is even being extended
by the addition of a full Matrix Processing extensions.

There have been multiple different ways to save and restore the state in
the FPU. Initially there was the `fsave`/`fnsave` instruction which
stored it in one format and handled the 80-bit FPU state. This was used
for a while and became part of the i386 System V ABI (more on that
later). The structure for this is the the
https://github.com/illumos/illumos-gate/blob/7b5987898994d86cd20e00dbf8c305dfbfbb8bea/usr/src/uts/intel/sys/fp.h#L178-L194[`struct
fnsave_state`] which looks like:

----
struct fnsave_state {
	uint16_t	f_fcw;
	uint16_t	__f_ign0;
	uint16_t	f_fsw;
	uint16_t	__f_ign1;
	uint16_t	f_ftw;
	uint16_t	__f_ign2;
	uint32_t	f_eip;
	uint16_t	f_cs;
	uint16_t	f_fop;
	uint32_t	f_dp;
	uint16_t	f_ds;
	uint16_t	__f_ign3;
	union {
		uint16_t fpr_16[5];	/* 80-bits of x87 state */
	} f_st[8];
};	/* 108 bytes */
----

Eventually, the FPU hit a series of extensions for both the MMX and XMM
instructions. This resulted in a new structure and a new series of
instructions. 8 128-bit registers were added that were called `%xmm0`
to `%xmm7`. This resulted in a new structure to save and restore the
state that covered both the traditional x87 FPU state from fnsave and
the new state with the `fxsave` instruction. This produced the
https://github.com/illumos/illumos-gate/blob/7b5987898994d86cd20e00dbf8c305dfbfbb8bea/usr/src/uts/intel/sys/fp.h#L201-L231[`struct
fxsave_state`]. This looks like:

----
struct fxsave_state {
	uint16_t	fx_fcw;
	uint16_t	fx_fsw;
	uint16_t	fx_fctw;	/* compressed tag word */
	uint16_t	fx_fop;
#if defined(__amd64)
	uint64_t	fx_rip;
	uint64_t	fx_rdp;
#else
	uint32_t	fx_eip;
	uint16_t	fx_cs;
	uint16_t	__fx_ign0;
	uint32_t	fx_dp;
	uint16_t	fx_ds;
	uint16_t	__fx_ign1;
#endif
	uint32_t	fx_mxcsr;
	uint32_t	fx_mxcsr_mask;
	union {
		uint16_t fpr_16[5];	/* 80-bits of x87 state */
		u_longlong_t fpr_mmx;	/* 64-bit mmx register */
		uint32_t __fpr_pad[4];	/* (pad out to 128-bits) */
	} fx_st[8];
#if defined(__amd64)
	upad128_t	fx_xmm[16];	/* 128-bit registers */
	upad128_t	__fx_ign2[6];
#else
	upad128_t	fx_xmm[8];	/* 128-bit registers */
	upad128_t	__fx_ign2[14];
#endif
} __aligned(16);	/* 512 bytes */
----

Importantly from the above definition you can see that it was changed in
amd64. The most notable change was the increase from 8 to 16 xmm
registers. AMD declared that part of the baseline for the amd64 ABI and
was used for a while.

==== Enter AVX and xsave

Starting with Intel's Sandy Bridge based systems, Intel started on a
trend of growing the FPU state. The 16 128-bit xmm registers became 16
256-bit ymm registers. You can guess where this is going by this point:
Intel needed a new save and restore mechanism again. This was introduced
with the `xsave` instruction. However, rather than make the structure a
fixed size, they actually did a bunch of additional work and created
something that has had the flexibility to actually withstand several
generational changes.

The xsave save area begins with the `fxsave_state`. It is then followed
by an xsave-specific header. The xsave header begins with two 64-bit
bitfields. The first 64-bit bitfield is used to indicate which
subsequent structures are present and valid and is called in Inte
parlance the 'xstate_bv' (or extended states bit vector). Each structure
begins at a fixed offset and has a pre-determined size which holds
regardless of whether the structure is actually valid (that is its bit
is indicated in xstate_bv). The fixed offsets and sizes are discovered
and described by CPUID leaf 0xd. Each state type uses a sub-leaf to get
tat information.

An important thing to realize is that these offsets **do** vary between
vendors and systems. For example if we look at a Skylake System that
supports AVX-512 and an AMD Genoa system that supports AVX-512, here are
the offsets of different features that we care about in illumos today:

.Comparison of xsave offsets
[opts="header",cols=3]
|===
| Feature | AMD | Intel
| AVX | 0x240 | 0x240
| AVX-512 OpMask | 0x340 | 0x440
| AVX-512 Hi256 | 0x380 | 0x480
| AVX-512 Hi16 | 0x580 | 0x680
|===

The important thing is that these offsets are basically only known at
run-time, but once the CPU is started, they shouldn't change. This has
important implications for the observability design that we'll come back
to later.

While there are many possible features in the processor, the OS may only
have done enabling support for a subset of them. As such, there is a
register called `xcr0`, which is the extended control register. This is
read and written to with the `xgetbv` and `xsetbv` instructions, the
latter of which is restricted to CPL 0 (e.g. the kernel). This is used
to constrain what `xsave` and `xrstor` will perform. In particular,
things are only saved and restored if they're enabled in xcr0 and in the
corresponding instruction masks / valid state bits. This makes it so
that even if a user sets additional bits into an xsave state, they won't
be saved or restored unless they're something that is known.

With the introduction of xsave, the OS moved to using it for saving and
restoring the FPU state on context switch; however, we did not update
anything in the signal handling or `/proc` paths to account for this in
the various ABIs (again more ahead).

==== Supervisor vs. User and State Explosion

Since AVX was added several more bits have been defined here. These bits
cover a wide variety of use cases and notably a split has been
introduced. Originally there were only states that were meant to be used
in all privilege levels such as AVX or the MPX bound registers so
`xsave` operated just fine in all privilege levels.

In particular, Intel added supervisor-only states that relate to things
such as the Processor Trace, Hardware P-States, and more. Instead of
setting things in `xcr0` there is a `IA32_XSS` MSR that is used to
control these settings in a similar way. The system then has to execute
the `xsaves` instruction to get the supervisor states into the xsave
structure. The `xsaves` instruction will also look at the user
components in `xcr0`, making it a single stop shop for the kernel with
the wrinkle of using a compressed form factor we'll mention in a bit.

With the addition of all these components into the xsave state, there
were several different things that have happened. There was the
introduction of an `xsaveopt` instruction that tried to save user state
in an optimized way using processor tracking. It sometimes makes sense
to use, but we can't always use it (e.g. in rtld). The second thing that
was done was the addition of a compressed form.

The way that the compressed form work is that the normal fxsave data is
still there, followed by the bitfields that describe what is present. A
particular bit is used in the second uint64 bitfield that the structure
is compressed. At that point, rather than use the cpuid defined fixed
offsets in the structure, each bit that is present in the feature set
has its data placed contiguously. So if the xsave structure had say only
one bit marked present in the bitfield, even if its normal cpuid offset
would suggest it be at much further part in the structure, it'll be
placed first. Some features require that they be start at the next
64-byte aligned section, so there often can still be padding.

The compressed form uses the `xsavec` instruction to save the resulting
state. To restore state, the normal `xrstor` instruction can be used,
but it has slightly different behavior. The supervisor state has to be
restored with the `xrstors` instruction and more confusingly, the
supervisor state can only use the **compressed** form.

This difference is important to note as it leads to some trickiness that
we need to consider. illumos does not make use of the supervisor state
at this point in time; however, the supervisor state makes an
interesting wrinkle that needs to be considered: the normal flush of the
FPU today only really considers that it contains user state and we'll
need to make sure that when we're going to and fro that we're not
potentially clobbering supervisor state.

===== Comparing the xsave variants

Given all of the above, it's worth summarizing the variants. They all
have slightly different behaviors and keeping them straight are
confusing. Whenever we're saving and restoring there is something that
Intel calls the 'requested-feature bitmap' or RFBM. This is specified in
registers and basically acts as yet another filter in terms of what is
saved and restored. A bit has to be both in that, `xcr0` or `IA32_XSS`,
and when restoring, the actual structure. The following table attempts
to summarize high-level differences.

.Comparison of xsave family instructions
[opts="header",cols=4]
|===
| Instr | Compressed | Supervisor | Optimizations
| `xsave` | No | No | init
| `xsaveopt` | No | No | init, modified
| `xsavec` | **Yes** | No | init-mxcsr
| `xsaves` | **Yes** | **Yes** | init-mxcsr, modified
|===

Let's take these apart. What the init optimization basically says is
that if a given component is in what it defines as the default state,
then these things will no bother writing them out and will not set the
bit in the xsave header indicating its presence.

With the `xsavec`/`xsaves` style the init modification changes a bit.
Basically there is a bit of a semantic thing they tried to fix, but it's
a bit confusing. In particular, if someone has set the MXCSR value to
something other than 0x1f80, then it will dump the XMM state if we
requested it in the RFBM.

The modified extension is a little more spicy. What ends up happening is
that the processor begins tracking when state has been modified relative
to the last restore of data; however, it also tracks a bunch of
information about where that save occurred which includes the address of
the state, privilege level, whether you're in a vmx non-root context,
etc. Ultimately, what these are all trying to do is to make sure that if
you're saving / restoring into similar places (like say lwp's pcb) that
you don't have to do everything if nothing's changed. Now the flip side
of that, is that it means that if you change what's inside that state
without a subsequent restore or something else to invalidate this, then
you likely are going to break the modified optimization, at least
reading between the lines.

Let's now turn our attention to the restore instructions. There are
three primary cases that we want o consider. The first is what happens
to the FPU state in the processor if the state bit isn't in the RFBM.
Next, we ask ourselves what happens if bit is set in the RFBM and not in
the xsave state and then what happens if it's set for both.

The other thing we need to consider is which bitfields do they use. When
a compressed save is used, the xstate_bv fields are set, but the
compressed form appears to also use the xcomp_bv member bits to indicate
presence. First let's discuss normal, uncompressed `xrstor` which has
the following properties:

* Logically RFBM does a binary-AND with xcr0 to determine the effective
  RFBM.
* If RFBM[i] is zero, the component is ignored.
* If RFBM[i] is one, but xstate_bv[i] is 0, the initial state of the
  unit is set.
* If RFBM[i] is one and xstate_bv[i] is 1, then the state in the xsave
  structure is set in the processor.

When `xrstor` operates on a compressed form, its behavior changes
slightly. While compressed information is written into xcomp_bv, it
still uses xstate_bv mostly because it is an error for a bit to be set
in xstate_bv, but not xcomp_bv. In particular, here's what's different:

* If a bit is not in xstate_comp, it will not be restored. This is in
  addition to requiring the bit to be set in xstate_bv[i].
* If RFBM[1] is set and xstate_bv[1] is 0, the MXCSR is set to 0x1f80.
  Normal `xrstor` apparently always sets the MXCSR from the xsave area
  if either RFBM[1] or RFBM[2] are set.

`xrstors` is similar to the compressed form of `xrstor`. In fact, it is
an error to restore an uncompressed format. The following differences
from the compressed form of `xrstor` exist:

* Valid bits to update are taken from both `xcr0` and `IA32_XSS`.
* If illegal values are set in any supervisor state component or the
  MXCSR value, then it will cause a `#gp`.

As we go forward into the discussion of what to do in the kernel, keep
the following in mind, as the fact that `xsaves` and `xrstors` only
operate on the compressed form is important.

==== Enter the Matrix

All of this seemed fine, but Intel has been adding a series of
instructions titled 'Advanced Matrix Extensions' (AMX) which are coming
in Sapphire Rapids. The notable thing is that this adds a 2D register
set called a tile which are used for tile-based matrix multiplication.
The initial register file is actually quite big! The new xsave state
component bit 18 is called `XTILEDATA` and is 8 KiB because it's 8 tiles
of 16 rows of 64-bytes each.

Now, recall that with eager FPU which whether it's a good idea or not
was required to work around speculative execution issues, requires that
the entire FPU state is saved and restored around each context switch.
So this is adding a large 8 KiB area to the xsave area, which most folks
probably don't want to pay the cost for as it means folks have to
actually set aside an additional 8 KiB of save area per process.

To deal with that, Intel appears to have added a new MSR entitled
`IA32_XFD` which stands for an extended feature disable. This
effectively introduces a new lazy FPU where a `#nm` is generated and
another new MSR, `IA32_XF_ERR_MSR` can be used to determine which state
components were at fault. In Intel's initial version in Sapphire Rapids
the docs suggest that only the XTILEDATA will cause this to happen. The
docs also make a bunch of exceptions for what will generate a `#nm`. For
example, many `xsave` and `xrstor` family instructions will not cause
this to change.

While we don't support AMX today, it's worth understanding what this
means and we'll go into that into a bit more detail when we discuss the
solution space. The important take away is that the amount of register
space this covers is only growing. As part of this, it's worth calling
out that because this has even more dramatic challenges with the signal
stack size and just the sheer cost of tracking and preserving these, in
Linux, Intel and others are exploring this functional unit not being
enabled by default for a process unless it promises that it's ok to use
it.

This has been implemented through an architecture-specific prctl related
function that was introduced in https://lwn.net/Articles/874846/[Linux
5.16].

==== Performance Gotchas

When AVX and AVX-512 in particular is active the CPU may often slow down
its overall clock rate. The interesting question is what determines
activity. Here it's worth calling out to some historical issues here
such as https://www.illumos.org/issues/9596[illumos#9596 Initial xsave
xstate_bv should not include all features] and
https://www.illumos.org/issues/9595[illumos#9595 rtld should
conditionally save AVX-512 state]. The main point of these is to keep in
mind that misuse of states can lead to the processor slowing down even
if we're not using the extended state, but just the processor believing
it is valid. Though we expect that processors have gotten better from
those days.

=== System V Context Operations

There are a suite of functions and data structures that have
traditionally been used to manage what were called contexts. This
involves the types:

* `ucontext_t` -- a somewhat opaque, ABI defined structure that
  describes the user's overall context.

* `mcontext_t` -- a somewhat opaque, ABI defined structure that
  describes the hardware-specific portion of a context. It is generally
  embedded in the `ucontext_t`.

Related to this are a suite of four functions that are often used for
obtaining these states:

* https://illumos.org/man/2/getcontext[`getcontext(2)`] -- This is used
  to obtain a context about for the current thread.

* https://illumos.org/man/2/makecontext[`makecontext(2)`] -- This takes
  an existing context and modifies it so that when it is restored, it
  will be used to call a specified function that is part of its
  arguments.

* https://illumos.org/man/2/swapcontext[`swapcontext(2)`] -- This
  provides a way of calling into a new context while retrieving the
  current one in one fell-ish swoop.

* https://illumos.org/man/2/setcontext[`setcontext(2)`] -- This takes
  the specified context and it makes it the current reality. A function
  call to setcontext does not return in the conventional sense.

These functions all exist for building up a way of performing user-level
context switching without the kernel being involved in knowing about it.
However, there are a couple things that are worth calling out that make
these different from when the kernel traditionally swaps out what's
running on the CPU:

* The kernel is really interrupting a thread and therefore must save and
  restore **all** of its state.
* When calling one of these functions, it is treated as a function call
  from a calling convention sense (whether getting or setting state).
  You'll also note that `makecontext` starts you at a function call
  entry. This means, the basic calling conventions about what registers
  have to be preserved or not need to be honored.

You'll note above we called the `ucontext_t` and `mcontext_t` somewhat
opaque. These structures vary for each architecture and vary between
Operating Systems. While the very original i386 `ucontext_t` and
`mcontext_t` were defined in the System V i386 ABI Supplement, the same
was not done in the amd64 documents or the much more recent ARM draft
documents. Despite all that, applications do assume that they can peak
inside and modify these structures.

In the strictest sense, these are not opaque and the types are a
fundamental part of the ABI. For better or worse, the primary
`ucontext_t` structure on x86 (that is for both 32-bit and 64-bit
environments) looks like:

----
struct  ucontext {
        unsigned long   uc_flags;
        ucontext_t      *uc_link;
        sigset_t        uc_sigmask;
        stack_t         uc_stack;
        mcontext_t      uc_mcontext;
        long            uc_filler[5];   /* see ABI spec for Intel386 */
};
----

Note, that while the `uc_filler` currently has a comment in the source
code that suggests seeing the ABI spec, this filler has not been used.
This is an important thing! Let's briefly discuss this structure. The
`uc_flags` member is used to indicate which other members are actually
valid and should be honored. There are flags that cover the signal mask,
the stack, CPU state, and FPU.

While this is the same on both architectures, the `mcontext_t` is quite
different because of the different registers that exist. The initial
`mcontext_t` structure is actually quite simple:

----
typedef struct {
        gregset_t       gregs;          /* general register set */
        fpregset_t      fpregs;         /* floating point register set */
} mcontext_t;
----

The `gregset_t` is actually just an array where the main difference is
how many registers are part of that state. The `fpregset_t` is where
things get interesting, nuanced, and is the true heart of darkness of
our problem.

The i386 version of the structure is phrased as what appears to be an
original `fnsave` style structure with a bunch of additional ways to
view the data. This was at some point in history amended to include the
8 xmm registers. It's not clear when that entered the actual i386 ABI
structure as it is not part of the original SCO ABI supplement.

The amd64 version however, is exactly the same as the fxsave_state (note
not `xsave`) with additional status words added on. This tied into the
default expectations of the ABI. All of this means that these functions
don't think about or handle anything related to `xsave`-based state.

It's an interesting question as to whether they can or cannot; however,
it makes it pretty hard to do based on the existing shape and
expectations of things like `getcontext(2)`. While the `uc_flags` member
is used to try to determine what is supposed to be considered valid and
not; however, it's pretty clear from the documentation that folks expect
most of the traditional default flags to be set and the kernel is not
meant to actually read the existing `uc_flags` member because is it
uninitialized stack garbage as part of a call to `getcontext(2)`. Put
differently, this is only valid in the context an initialized structure.

With this understanding of the context structures, let's go and dive
into everyone's favorite UNIX feature: signals!

=== Signals in the Dark

So where does all of the above collide: signal handling. Let's discuss
what happens on a signal and how illumos returns from a signal. Signal
handling has an important semantic: The signal handler basically has its
own register state and shouldn't be able to really change the register
state of the interrupted context (absent explicit action). In this
sense, it's much like a hardware interrupt or really like the kernel
opting to switch away to another thread.

So, how does this actually become reality? Every instruction set
architecture implements a `sendsig()` function in the kernel. This is
responsible for figuring out how to actually make a signal reality.
Signal handling is a joint cooperation between libc and the kernel.
Let's first go into what the kernel does when a signal is to be
delivered:

. The kernel looks at the signal's mask and disposition. If the signal
is masked, nothing really happens. If the signal's disposition is to
ignore it or to kill the process, then both of those things happen.
Let's assume we're delivering a signal.
. The next thing the kernel does is to determine whether or not the
signal should be delivered on the current stack or an alternate stack.
. It begins to construct a stack frame that varies between i386 and
amd64.
. The system saves the current thread's context with the equivalent of
the `getcontext(2)` system call.
. The entire `ucontext_t` structure is pushed onto the stack.
. Pointers to a `siginfo_t` are pushed on the stack (which itself may
already be there)
. The signal number is pushed onto the stack.
. A garbage return address is pushed onto the stack.
. It changes around the current registers that the process will resume
with changing things like:
* Making the stack pointer point to the signal stack.
* Changing the instruction pointer to map to whatever function libc had
  registered previously and giving it the appropriate arguments.
* Making sure that various segment registers, and other bits are set up
  to ensure reliable delivery.

Unlike some other kernel implementations, the `sigframe` and
`sigframe32` structures to not exactly cover the entire format (e.g.
they don't include the ucontext_t). After the context is saved and
everything is set up, the thread will copy everything out, and then
proceed to return to user land. If for some reason signal delivery
failed (e.g. invalid alternate stack pointer, stack overflow, etc.) the
kernel will proceed to instead kill the process.

When the signal comes to userland, we arrive in the main libc entry
point: `sigacthandler`. When a process calls
https://illumos.org/man/2/sigaction[`sigtaction(2)`] to register a
signal handler, libc stores that information itself and then registers
its own function as the entry point and there are a bit of things that
libc will do before calling the actual signal handler. Once the signal
handler has completed, then we will normally come back to this call and
libc will finally return to the original context calling `setcontext(2)`
on what it was given.

You'll note that we said that we only saved the `ucontext_t` above and
that the `ucontext_t` only actually contains the basic ABI state so on
amd64 in particular, this only has the original `fxsave` state. This is
exactly what leads to the issues that we saw
https://www.illumos.org/issues/15254[illumos#15254 %ymm registers not
restored after signal handler].

Applications though are actually allowed to change the `ucontext_t` on
the stack. That is, they know that they have a `ucontext_t` passed to
them in the signal handling function (assuming they filled out
`sa_sigaction`) and folks then do modify the context that they return
to. This actually happens with programs more than you might expect.
Consider the case of the Java Virtual Machine. When it has a
`NullPointerException`, that has in the past actually been the `SIGSEGV`
signal being handled.

While whether modifying state should or shouldn't be done may be a
reasonable question, the reality is that folks do and therefore we need
to consider this and this adds further cementing of the `ucontext_t` and
`mcontext_t` ABI.

==== Jumping Away

All this is fine, but there's more nuance here: one can actually return
out of a signal another way. You can actually use the
https://illumos.org/man/3C/siglongjmp[`siglongjmp(3C)`] family of
functions to leave things in a context of a signal handler. So what's
happening here? First, the `jmp_buf` is an opaque array that we just
happen to stuff a `ucontext_t` into. Fancy that. This is done in a
combination of assembler and C functions, but does not ultimately call
`getcontext(2)`.

It also does not actually obtain or save the floating point state! So
this means that jumping out of this state leaves the FPU in a rather
undefined state. In particular, we don't actually have `UC_FPU` set in
the context and thus we don't actually restore the FPU state to anything
and it is left as whatever it was when it was last used.

==== Sizing the Signal Stack

Traditionally, a combination of POSIX and System V standards have led
there to be definitions for the minimum and a default signal size used
for the stack. In particular, these constants have been:

`MINSIGSTKSZ` and `SIGSTKSZ` which is a recommend size. These
respectively have been 2 KiB and 8 KiB. While this was kind of ok in the
days of the original x86 `ucontext_t`, with the ever increasing size of
the `mcontext_t`, we need to think a bit more proactively here. In
particular, it can be possible that by the time all of the xsave state
is dumped to a stack, that it will not be able to handle the signal or
overflow an alternate signal stack.

There has been a bit of prior art in handling this. In particular, glibc
has gone and made these macros calls to
https://illumos.org/man/3C/sysconf[sysconf(3C)] in many situations. As
part of us evaluating the solution space, we will be exploring this in
more detail. But this is yet another piece of the puzzle.

=== /proc and Core File Observability

`/proc` is the main what the debuggers and the system have observability
about the state of registers in the system. This shows up in a bunch of
different places using the types of `prgregset_t` and `prfpregset_t`.
These structures are basically the exact same as their `mcontext_t`
compatriots of the `gregset_t` and `fpregset_t`, being all of a
`#define` in the x86-specific procfs headers.

Traditionally the registers for a thread are read out of its `lwpstatus`
file (i.e. `/proc/<pid>/lwp/<lwpid>/lwpstatus`). This provides a field
for both the general and floating point registers. In turn, registers
are set in a different way. Here, the `PCSREG` and `PCSFPREG` commands
are issued upon the `/proc/<pid>/lwp/<lwpid>/lwpctl` file determined by
a write. This is also abstracted by
https://illumos.org/man/3LIB/libproc[libproc(3LIB)] and its
corresponding functions such as
https://illumos.org/man/3PROC/Plwp_getregs[Plwp_getregs(3PROC)] and
https://illumos.org/man/3PROC/Plwp_setregs[Plwp_setregs(3RPOC)].

There are several additional files that exist in per-LWP directory in
`/proc` that cover different aspects of the process. In particular, one
of the files is the `xregs` file which is meant to contain extended
registers that are ISA-specific. There is a corresponding write
operation entitled `PCSXREG` that covers writing this and parts of
libproc.

The ELF notes that are used to make up core files follow a similar style
which are documented in https://illumos.org/man/5/core[core(5)].
Effectively, for every LWP we will write out a note with the contents of
the corresponding `prgregset_t`, `prfpregset_t`, and the `prxregset_t`.
Right now x86 doesn't have an `xregset` file or definition, so nothing
is written out there.

==== libc_db

The https://illumos.org/man/3LIB/libc_db[libc_db(3LIB)] library is mean
to provide a means of additional ways of getting access to additional
information about threads, their registers, and related. In many ways
this is a library that was born ahead of libproc. This library and the
corresponding
https://illumos.org/man/3PROC/proc_service[proc_service(3PROC)]
interfaces have the ability and expectation to read and write registers.
We call these out here as if we are improving observability we need to
make sure that this is part of this.

== Problem Summary

Before we go into a survey of what others have done, given the above
background, let's summarize what we are actually trying to solve and our
constraints on the solution space. First our problems:

. We need to properly save and restore the FPU xsave state across the
signal handler.
* As part of this we need to set clear expectations about what state is
  saved and restored across calls to `getcontext()` and `siglongjmp()`.
* We also need to assume that folks want the ability to modify the xsave
  state in the signal handler, regardless of our views on the merits of
  that.
. We need to improve the observability of the xsave state both for
debuggers and core files. Specifically this includes:
* Updating `/proc` to have files for this (i.e. `xregs`).
* Updating libproc and mdb to get access to this state.
* Updating the suite of surrounding tools and documentation.
. We need to improve the way that signal stack sizing is performed for
applications to avoid issues for AVX-512 which is increasing prominence
with Zen 4 and get ahead of what might happen with AMX.

We have the following constraints that we need to honor:

* We must not violate the existing ABI contract of the `ucontext_t` and
  `mcontext_t`.
* We must assume that certain applications will assume that they have
  access to all AVX state, including AVX-512, regardless of the size of
  their stacks.

The following are explicit non-goals of this work (but it is possible
some of them fall out for free):

* Enable support for Intel AMX.
* Change the kernel to take advantage of the compressed save format and
  supervisor states.
* Enhance rtld to leverage the compressed save format.

=== System Survey

As part of working on this we have gone through and surveyed several
other system to try and answer the following questions:

* Do they save the entire xsave state in a signal handler?
** If so, what format does that leverage? The compressed or the
uncompressed?
* Does `getcontext()` save xsave state at all?
* What, if any, `/proc` style interfaces to these registers exist?

[cols=6,options="header"]
|===
| Question
| https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=77856d911a8c8724ee8e2b09d55979fc1de8f1c0[Linux]
| https://github.com/freebsd/freebsd-src/tree/aba921bd9e1869dae9ae4cc6e0c048f997401034[FreeBSD]
| https://github.com/NetBSD/src/tree/9ebc005c7122f6014596209d153a73cf72895112[NetBSD]
| https://github.com/openbsd/src/tree/0cffdb45a9bb573ce4665f5540d1a0d50ff2e37f[OpenBSD]
| Solaris 11.4
| xsave in signal hander | Yes | Yes | No | Yes | Yes
| Compressed in ucontext_t | No | No | N/A | No | Yes, but no*
| Kernel uses xsaves | Conditionally | No | No | No | Unknown
| getcontext xsave | Appears no in glibc, not present in musl | No | No | getcontext() was removed | No
| Register access
| Full xsave state via ptrace | Full xsave state via ptrace
| Full xsave via ptrace and `/proc`
| fxsave state only?  | Uses own data format via `/proc`
| `MINSIGSTKSZ` | 2 KiB (musl, glibc), affected by kernel aux vector | 2 KiB | 8 KiB | 3 pages | ???
| `SIGSTKSZ` value | 8 KiB (musl, glibc) | 36 KiB | 40 KiB  | 7 pages | ???
|===

There are a few different and useful takeaways from the above. Here are
the highlights as we see them:

* It is expected (no surprise) that xsave state should be saved in the
  signal handler and accessed via pointers in the ucontext_t.
* Pretty much all implementations that still have `getcontext()` do not
  try to handle xsave state in it and just use the traditional ABI
  registers, if anything. This is good news for us.
* Aside from Solaris, the main way to access state is via a full xsave
  state, which is not compressed. In the case of Linux, this is mostly
  because that was the original user ABI, even though the kernel is now
  using the compressed form factor in many cases.
* In general, the actual default and minimum signal stack sizes do vary
  a bit more widely than expected. This does give us a bit more
  flexibility than we might expect.
* Regarding NetBSD, experimental evidence suggests avx state is saved
  and restored; however, the
  https://github.com/NetBSD/src/blob/9ebc005c7122f6014596209d153a73cf72895112/sys/arch/amd64/amd64/machdep.c#L628[cpu_getmcontext()]
  call in the signal handling code leads to
  https://github.com/NetBSD/src/blob/9ebc005c7122f6014596209d153a73cf72895112/sys/arch/x86/x86/fpu.c#L722-L733[process_read_fpgres_xmm()]
  which only covers the fxsave data, though there is evidence of xsave
  being used elsewhere. Most likely, we just haven't properly followed
  the logic there.

You'll note that we described Solaris as not quite using the compressed
form factor. What they've done is to cause the xregset structure to have
every state item that they currently support at fixed locations;
however, they do not necessarily follow from the CPU's actual defined
offsets. Thus this is not quite the xsave compressed format but neither
is it strictly something that can be directly tossed into the xsave
format.

== Solution Sketch

This section sketches out how we propose fixing and extending various
pieces here.

=== Signal Handling, ucontext, and getcontext(2)

Fundamentally we need to save and restore the extended register state in
the signal handler, while accounting for the fact that it may have been
changed partially in user land.

We start by using a new flag in the `ucontext_t` `uc_flags` member,
which we call `UC_XSAVE`. In particular, this is not the same as what
Solaris has done, hence why we don't want to use the exact same name.
Let's call out a few important items here:

* When both `UC_XSAVE` and `UC_FPU` are specified, then when restoring,
  the ``fpregset_t``'s version of the legacy save area will override
  whatever is in the `UC_XSAVE` area. This preserves existing semantics
  in the ABI. If `UC_FPU` is not set, then it will not change anything.
  This is similar to how Linux handles the overlap between SVE and Neon
  on ARM.

* While other signal handling contents are generally considered public,
  as we are introducing this and we know no applications can modify this
  state, we would like to make this **private** to start with. This will
  allow us to consider evaluating using the compressed form here,
  minimizing the likelihood of signal handler impact.

* The `getcontext(2)` system call will not fill in or set `UC_XSAVE`.

* If bad data has been placed in `UC_XSAVE`, we will consider that fatal
  and depending on the specifics of the implementation, consider killing
  the process.

With these constraints in mind, the question that we have is what is the
right form for actually writing and reading the data in the signal
handler. In an ideal world, we would consider reusing the `prxregset_t`
structure that we discuss below. If we were going to support
applications modifying this data, then we would say that it makes the
most sense to use only one. However, the tradeoff with what is proposed
below is basically space. If AVX-512 is supported (in the first case and
irregardless in the second proposal), then we will already overflow the
minimum signal stack size. While we have subsequent proposals for this,
it does cause us to pause and ask what makes the most sense, especially
given that most application are not using that extended register set.

This ipd does not constrain what the implementation will be and we allow
that to be determined based on the experience implementing the various
pieces and understanding what they look like with a weak bias towards
the `prxregset_t` if we can manage to make that fit. Regardless of our
choice, it will be treated and documented as private.

=== /proc and xregs

One of the principle things that makes the current situation harder is
the lack of observability of this extended register state in the
processor. The `xregs` file and the `PCSXREG` command cover this use
case. The question that then leads us to is what is the actual design
that we should use for this.

First a few observations:

* One on the one hand, we would prefer to use a valid xsave-style
  structure, because this makes it easier for applications to
  potentially use this for their own purposes and makes it easier for us
  to implement that. However, there are a few notable challenges:
** The offsets of the xsave structure vary from CPU to CPU.
** Not all CPUs support the compressed xsave structure.
** The simplicity in the implementation may disappear the moment we use
   a compressed form in the kernel if we're not using the compressed
   user form.
** It is not clear if this is actually a valuable property in practice.
   Applications that actually wanted to manipulate their own state
   directly probably would not use `/proc` for it and a debugger itself
   would just use the setting capabilities to set this for a given
   thread. There isn't much value in using the agent LWP for this.

* There are many states in an xsave structure that the OS doesn't use or
  support, making it such that the actual uncompressed format can be
  quite wasteful. However, the compressed form may skip components,
  which means correctly assembling something can be much more difficult.

* Core files and debuggers need to know the ordering of the structure
  layouts. We don't want folks to have to call cpuid to obtain specific
  information.

* The set of features which may be sent in these structures is going to
  change over time, making compatibility a concern. This gets harder
  when we consider AMX and the fact that it is unlikely to be enabled or
  opted into by default and will instead be disabled until asked for by
  the process. This may change what we want to include.

* While there is some space for software in the xsave header which is
  ignored, we also want to assume we may have auxiliary information
  that, while not today, will eventually exceed that space. Examples of
  this include providing read-only access to `xcr0`, `IA32_XFD`, etc.

With this in mind, let's start by noting a few paths that we don't think
work well on their own. In particular, we don't want to just make this
the raw `xsave` standard or compressed form factor with no other
metadata. This would cause us to need to expose this information in
another way, whether a separate system call, `/proc` file, ioctl on the
cpuid device, or something else. It would also require us to get a
separate ELF note in a core file.

If we look at the different implementations, what Solaris has done here
is to suggest their own fixed layout that includes every user state
component that exists. The benefit to this approach is that there is a
fixed layout that can always be used and is extensible. It does mean
that if a given CPU doesn't support a component, there is more that
needs to be done to translate to and from the appropriate type. An
application will need to review the embedded version of `xcr0` to see
what fields in this structure are actually valid and allowed to be used.
Just because a field is in the structure does not mean that it is legal
to fill out say the ZMM state because a CPU may not support AVX-512. In
addition, it also means that for an application to be able to use this
structure, they will need to do more work.

This last concern rears its head in a different way when we consider the
actual compressed form factor. While the compressed form factor is a
simpler way to express this structure, it makes it much harder for an
application to be able to transform the values found into something
else. Now, this cost may be something we can mitigate with say `libproc`
taking care of the lifting and reinsertion, so these considerations may
not hold much point as it is likely that it'll end up wanting to
restructure the data internally to the library to make manipulating this
easier.

Traditionally the `/proc` structures are all a giant structure or union
with fixed and known offsets. Deviating from that isn't unreasonable and
buys some flexibility; however, it does come with some costs and
complications. Applications would need to know how large a structure to
allocate to cover everything and the static structure would not be the
best. However, it may be that as this state continues to grow, as Intel
shows no sign of stopping, that declaring this on the stack is really
not an acceptable long-term path due to its growth. Given that just the
AVX-512 state and the AMX state is already 10 KiB, what is being saved
may no longer be worthwhile. We also need to remind ourselves that this
is not the hot path and memory allocation occurring somewhere is not the
end of the world.

With that in mind, let's get to a few different concrete proposals:

==== The Hybrid Approach

Our primary proposal right now is a hybrid design here. The `xregs` file
would include not just the raw data, but also structures that described
where to find everything. Consider an initial `prxregset_t` header that
looks like:

----
typedef struct prxregset_info {
	/*
	 * Types are semantic types that we define, not necessarily,
	 * though generally 1:1 mapped to xsave bits.
	 */
	uint8_t pri_type;
	uint8_t pri_pad[3];
	/*
	 * Example flags include right now:
	 *   o Entry included, though that could be covered by offset is
	 *     zero
	 *   o 64-byte alignment required in compressed
	 */
	uint32_t pri_flags;
	uint32_t pri_size;
	uint32_t pri_offset;
} prxregset_info_t;

typedef struct prxregset {
	uint32_t pr_type;
	uint32_t pr_size;
	/*
	 * Flags used to indicate extensions.
	 */
	uint32_t pr_flags;
	uint32_t pr_data_off;
	uint32_t pr_ninfo;
	prxregset_info_t pr_info[];
} prxregset_t;
----

Each of the info entries would describe where to find a given state
component. As the xsave area is required to always have the legacy and
xsave header, that is what the top-level `pr_data_off` would indicate.
The top-level `pr_type` would indicate that it is this particular
version of an xsave style data and `pr_size` would reflect the total
overall size of the structure.

By including where to find everything and telling applications that that
is what they should rely upon, it allows us to optionally rearrange and
compress items to minimize what we copy out versus just zero in the
future. However, we would generally suggest that this mimic the standard
uncompressed xsave structure and that the info pieces and the initial
header would be expected to be read-only. Put differently someone using
`PCSXREG` would still write this information, but it would be expected
to match what we have already written there. This still allows someone
to fill out a component that would have been optimized away in the
compressed format. This would ultimately look like:

----
  +-----
  | prxregset_t
  | header
  +-----
  +-----
  | prxregset_info_t []
  | metadata
  +----
  +-----
  | Padding to 64 bytes
  +-----
  +-----
  | full, uncompressed
  | xsave structure
  +-----
----

This does require more user work to parse it (hopefully made easier by
libproc). It also means that users would need to either read the header
or stat the file to determine how large it should be. But this has a few
advantages in that it does allow us to create a more compressed variant
in the future that is tailored to the features that the process is
allowed to use and also means that features that aren't supported on the
CPU but are on another aren't there.

An open challenge with this is that while it would give us the ability
to later optimize what is in here with respect to offsets and
compressing the file's overall size and allow us to ignore a lot of
zeros on some processors, we could not do so without eliminating the
ability to use the actual xsave structure. It is not clear that that is
a valuable property.

An alternate consideration here is to allow us to take any xsave state
being written to us. That is writing this doesn't have to use or
leverage the offsets that we have written in. That would allow us in
theory to write a compressed save state out here and allow someone else
to write a new compressed state that didn't have this information.

==== Alternate Approach: Fixed Structures

An alternate approach is to take something that more or less follows
with Solaris has done here. This would require us to make sure we expose
`xcr0` (which we should do anyways). This still requires consumers to
parse the information that exists to determine what is valid and what
will be accepted. The main difference between this structure and the one
above isn't that things won't have some parsing, but what parsing tells
us. In this world we need to figure out both if a state component should
even be valid, and then, is it present. In the prior world, you only
need to determine if it is present, only items that could possibly be
valid (even if they're in their initial state) will be written out.

In this case, the structure might look something like:

----
typedef struct prxregset {
	uint32_t pr_type;
	uint32_t pr_size;
	uint32_t pr_pad[2];
	struct fxsave pr_fxsave;
	struct xsave_header pr_xsave;
	/* YMM state */
	/* ZMM state */
	/* future supported user structures */
} prxregset_t;
----

We could also look at making this binary compatible with Solaris, though
there are a few considerations that we would need to make that may
eventually lead to us no longer being compatible as while we're playing
catch up here, we do not want to say that we can't add something because
they haven't. There are a few other questions that we want to ask
ourselves in genera with this approach:

* Do we want to include MPX when we don't support it and it seems in
  general support for MPX is on the decline as it was removed from the
  https://gitlab.com/x86-psABIs/x86-64-ABI/-/merge_requests/39[amd64
  psABI]?

* Does it matter where we insert registers for things like `xcr0`,
  `IA32_XFD`, and other information required for someone to tell how
  they fit in?

=== libproc and mdb

The libproc design expects a single atomic getting and setting of the
entire register set today with the `Plwp_getregs`, `PLwp_getfpregs`, and
`Plwp_getxregs` families. libproc also has functions like `Pputareg` and
other related things which are used to get individual registers and
thread-specific versions that are used by tools like `truss` and `nohup`.

Today, mdb does not support setting the FPU regs. While there are the
bulk get/set entry points, we think it may be worth adding more specific
entry points into libproc for FPU registers ala `Lputareg`. As part of
this we will explore the following:

* Updating mdb to ensure that it will output all of the vector FPU
  registers as appropriate and figure out a way to better show different
  vector sizes as well as specific, individual registers.
* Exploring ways in mdb and libproc to update individual FPU registers
  and understand what the largest alias of a register is. This is all in
  addition to the exisitng bulk put interface that libproc offers.
* The existing libproc xregs functions will be re-evaluated due to
  allocation needs that are going to continue to stem here. The existing
  libproc APIs do not provide the required fleixibility for the
  structure increasing in size for existing consumers.

The exact APIs that will come out of this and user interfaces will be
subject of exploration during development.

=== Signal Stack Sizing

To facilitate proper sizing of stacks, we propose that the following
macros are transformed into sysconf calls similar to what glibc has
done:

* `MINSIGSTKSZ` turns into `sysconf(_SC_MINSIGSTKSZ)`
* `SIGSTKSZ` turns into `sysconf (_SC_SIGSTKSZ)`
* `PTHREAD_STACK_MIN` is already `sysconf(_SC_THREAD_STACK_MIN)`

While GNU requires guards for these and strictly speaking these may not
be the most POSIX compliant forms, we propose to make them default to
this form initially unless issues crop up when performing bulk builds.
Given that this has already been done for the pthread case, that gives
us additional confidence to do this.

Internally, libc will determine these sizes based on a heuristic and
dependent on the `AT_SUN_FPSIZE` auxiliary vector macro. Sizes will be
rounded up to the nearest 1 KiB boundary after taking this into account.
A word of caution that we should consider here is that right now this is
meant to help tell rtld what to do. If we were to adopt the use of
`xsavec` in rtld to reduce the save/restore amount and allocation, then
we may need to think more carefully about this size as in theory we
could tell rtld to reserve less stack usage based on what we know is
enabled in xcr0. The second cautionary tale for this is that once we
commit to requiring AMX to be explicitly enabled, that means that this
value can change. While it likely makes more sense to address this when
we get to the point of supporting AMX, it's worth keeping in mind. Other
systems have introduced an `AT_MINSIGSTKSZ`; however, that's not really
what we want to have for things like rtld to figure out the best course
of action. For the time being, we opt not to change anything.

We suggest the following initial computations:

* Minimum stack sizes should start from the existing libc definitions of
  4 KiB and 8 KiB (which is what is returned in
  `sysconf(_SC_THREAD_STACK_MIN)`. If the FPU state is more than 1 KiB,
  then we should increase the stack size correspondingly.

* We should increase the default signal stack sizes probably from 8 KiB
  to at least 32 KiB, increasing it again if the FPU state size is more
  than 1 KiB.

The next complication to consider is what do we do in the actual
implementation of `sigaltstack()` in the kernel. In particular, it
checks that the size is at least `MINSIGSTKSZ`, which applications have
historically thought to be 2 KiB. Strictly speaking some applications
may have a very bad day on an alternate signal stack with AVX-512
active. However, in the spirit of backwards compat, it is likely better
to allow this applications to run and then fail at run-time if such a
case actually occurs than to fail `sigaltstack`.

This suggests the following options to consider:

. We retain to the 2 KiB minimum stack size in `sigaltstack()` for all
programs and just allow a run-time failure when this occurs. While not
great, this isn't dissimilar to a stack overflow; however, it's one the
system could have helped avoid.
. We introduce a new symbol version for `sigaltstack()` such that newly
built software can be told your alternate signal stack is too small.
This when combined with the changes to the macros used, should allow us
to at least be in a reasonable spot to avoid failures for applications.
If this approach was taken, we should change the approach by which this
information is derived and have `sysconf` ask the kernel for it
dynamically as a way of preparing for AMX.
. We just begin failing calls that don't meet the new minimum signal
size, saying we're sorry this no longer runs, but it's better than the
possibility of overflowing your stack. This could be varied to determine
whether or not we actually fit the signal stack or not.

While it has more complexity, it is likely that (2) is our best option
and gives us the right balance of making sure new applications can get
proper failures while existing, built things aren't broken on an update.
It does increase the testing burden of that change and at the minimum an
audit of illumos internally.

== Recommendations for New Architectures

This section provides several suggestions for how to think about new
architecture ports that are ongoing or yet to be undertaken and things
to do to make this process smoother, if possible.

UCONTEXT::

* Architectures should ensure that `uc_flags` has free values and that
  there are several pointers worth of `uc_filler`. Assume that brands
  will use one word of filler at least, that we will want a pointer
  to an extended FPU state, and that there must be at least one word as
  an escape hatch for additional things. We suggest at least 4 longs
  worth of data, plus whatever filler shows up due to padding.
* There are two approaches to how to construct the `mcontext` and
  `ucontext` state. What matters here is whether extended vector state
  is meant to overlap with the basic FPU state or not. For example on
  x86 there is clear overlap and on ARM SVE overlaps with VFP/Neon.
** Where there is no overlap, we suggest that folks build the basic
   stable FPU registers into the normal mcontext and have a variable
   lenth pointer ala what is described here for the rest of it.
** On systems where the two states overlap, we suggest only having a
   single save state to avoid the challenge that we have with the
   traditional FPU and the other pieces. What is viable will depend on
   the calling conventions of the platform and the save instructions. If
   possible, avoiding the encoding of the FPU in a fixed register is
   recommended due to challenges there.
* While adding padding to the mcontext may be useful, it is hard to
  predict what is a useful amount. There is no good way or appropriate
  amount to reserve that'll properly cover everything, therefore the
  best courses is to focus on the fact that signal handlers can spill
  everything and then to minimize what extended registers are stable
  interfaces until the need is proven otherwise.

SIGNAL STACKS::

* The `MINSIGSTKSZ` and `SIGSTKSZ` should always be their `sysconf`
  based alternates.
* Applications should always fail if they request too small a signal
  stack.
